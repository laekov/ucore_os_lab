Lab7 实验报告
===
## 练习零
略
## 练习一
### 内核中的操作
`up` 和 `down` 函数直接调用了 `__up` 和 `__down` 函数.

为了保证 pv 操作的原子性, 具体实现时还是采用了屏蔽中断的方式.

`up` 相当于 V 操作. 查询等待队列. 若有等待中的进程, 则唤醒这个进程, 否则将信号值加一.

`down` 相当于 P 操作. 如果信号量表示可进入状态, 就直接进入, 否则将自身扔进等待队列, 然后调用 `schedule` 接着跑其它的进程, 直到被 V 操作从队列里拉出来, 然后从等待队列里把自己删掉并接着执行.
### 向用户态提供服务
将 PV 操作作为一种系统调用提供给用户, 并对每个 `sem` 对象的权限进行规定.
## 练习二
### 内核条件变量
内核中对条件变量的操作相当于是对信号量的一种封装.

这时候 `mutex` 这个锁只管谁在测试和修改条件变量. 而测试条件变量如果不满足的话, 将会放弃自己的执行进入等待, 直到它被别的 `signal` 的回调函数唤醒满足条件.

而当一个人吃完后调用 `signal` 函数时, 它会查询左右的人是否还需要吃, 即试图唤醒上面的把自己挂起的别的线程.

一个坑点在于 `cprintf` 函数并没有加锁, 所以多个进程的输出的行之间可能会交叉. 所以要对 `vscprintf` 函数加锁. 这里我使用了最简单的屏蔽中断的方式.
### 对比
相对于直接使用信号量, 条件变量允许进程在临界区时让下一个进程来执行, 而自身又不结束. 具体来讲, 它是将较多的信号量封装成更抽象的方法来方便使用.

苦要在用户态使用条件变量, 也是将条件变量的函数套上系统调用来实现.
### 用信号量实现条件变量
具体实现就是这么干的. 有一个 `mutex` 信号量和一个 `next` 信号量. `mutex` 仅存有当前的进程, 而其它进程都在 `next` 信号量里排队, 当释放资源时, 直接从 `next` 队列中拿下一个进程来执行即可.
## 知识点
信号量和管程的具体实现方式, 虽说与禁止中断有理论上的区别, 但是实际上禁止中断是最底层的实现方式, 而其它方法实际上都是在它上面完成的.

管程的等待和释放方式可以较为复杂, 互相调用的时候可以构造出比较麻烦的逻辑题.

ucore 中实际上使用了一经释放直接执行的方式. 这与另两种上课讲到的唤醒方式可以作一些对比. 其中有两种方式的区别还没有完全说清楚.